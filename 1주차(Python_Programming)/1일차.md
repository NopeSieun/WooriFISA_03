###  07.08 (1일차)
---
오리엔테이션을 진행했다. 출결 90% 이상 충족하면 우수 수료생이 될 수 있다. 깃에 직접 정리하는 건 처음인데 생각보다 편하고 깔끔한 것 같다. 약간 일기장? 메모장? 그런 감성? <br><br> 
- **마크다운 작성 방법**
    - **굵게**(**), __굵게__(__), *기울게*(*), ~~취소선~~(~~)
    - > '>'를 사용하여 인용 가능
    - `print('백틱(``)을 사용하여 한줄코드 가능')`
***
<br> 

###  07.09 (2일차)
---
실무를 위한 코딩센스를 배웠다. 회사에 들어가게 되면 작은 센스도 중요하다고 한다. 조급해하지 말고 여유를 좀 가지면서 일단은 공부에 집중하자는 마인드를 갖게 되었다. 넣는 족족 다 떨어져서 자기 합리화 한 거 아님.. 아무튼 아님........그리고 옆 건물 망고주스가 대박 맛있음!진짜 망고<br><br> 
- **프로그래밍과 코딩은 같은 말인가?**
  - 프로그래밍은 프로그램을 작성하는 과정, 그 안에 코딩이 포함되어 있는 것 
- **확장자 비교**
  - .py: 파일 안에 있는 내용이 한 번에 실행됨
  - .ipynb(interactive python notebook): 코드셀 단위로 실행되며 텍스트셀 지원 (노트북 파일)
- **코딩 센스 기르기**
  - 코드가 길어지는 경우 백슬러시(\)를 이용해 줄바꿈
  - 연산자로 길어지는 경우 연산자 이전에 줄바꿈하는 것이 좋음
    ```python
    income = (gross_wages + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
    ```
- 이름 작성을 위한 규칙을 잘 지키는 것이 좋음 - **네이밍 컨벤션(convention)**
  ```python
  class MyClass(): #pascal case

  my-documents #kebab-case (URL)
  my_documents #snake_case (Python)
  my-documents #camelCase (JAVA)
  ```
- **언더바로 시작된 변수**: 함수 등의 내부에서만 사용되는 변수<br>
    `_my_list = []`
- 라이브러리/파이썬 기본 키워드와의 충돌을 피하고 싶을 때 **밑줄(_)** 사용<br>
  `import_="not import"`
- **REPL(Read, Evaluation, Print, Loop)**
  - 인터프리터의 동작 과정, 명령어를 읽고(번역, 기계어(binary)로 변환)-실행-결과 돌려주고-반복
- 작은 따옴표 안에 작은 따음표 넣고 싶으면 앞에 **escaping 문자(\)** 넣기 <br>
    `docs = 'this\'s a dog'`
- 잘 쓴 것 같은데 계속 에러가 난다면 앞뒤에 **공백**이 숨어있는지 확인해보기
- **시퀀스 타입**
  - 가변형 타입: 자료 값 변경 가능 (ex.list)
  - 불가변형 타입: 자료 값 바꿀 수 x (ex.tuple, range)
- **slice**: out of range 에러 피할 때, 특정 순서에 의해 일부를 떼어다 쓸 때 사용하기 용이 
  ```python
  tu1 = (1, '안시은', (1, 2), 3.15, None)
  tu1[0:7:2]
  #결과: (1, (1, 2), None)
    ```
- **코딩의 두 가지 종류**
    - 소프트 코딩: 자료가 변하면 결과도 달라지도록 하는 종류의 코딩 -> 일반적
    - 하드 코딩: 자료가 변해도 계속 같은 결과가 나타나도록 고정하는 종류의 코딩
- **append**: 추가/ **extend**: 확장/ **insert**: 끼워넣기
- 실무에서는 **dictionary**를 많이 쓴다. 
    - getter(값을 가져오는 함수)/ setter(값을 변경하는 함수)
  - JSON 형식과 쉽게 호환되기 때문에 사용 多

***
<br> 

###  07.10 (3일차)
---
아직도 수요일이라니 믿을 수 없음.. 간식이 너무 많아서 일주일에 1kg씩 살크업 할 것 같고 이제 겨우 3일짼데 벌써 점심 뭐 먹어야할지 모르겠어서 여러모로 걱정이 된다. 아무튼 ~~코테를 잘 풀 수 있는~~ 쉽게 설명할 수 있는 가독성 좋은 코드를 구현할 수 있는 개발자가 되자! <br><br>

- **python tutor**: 코드 실행 과정을 확인해볼 수 있는 시각화 도구
<img src="https://github.com/NopeSieun/WooriFISA_03/assets/83575791/755cf8bc-9300-4cef-baf8-55891cb7242d" width="50%" height="50%">

- if문의 if 뒤에는 **bool()** 이 숨어있음
  - if 빈 문자열/ 리스트/ 딕셔너리/ 0 이면 아무 결과도 나오지 x
-  **match-case**
    - `case _:` #와일드카드, 앞의 조건을 제외한 모든 경우
    - `case['score',*z]`: #*, 나머지 요소 모두 저장하는 변수 앞에 붙임 
- **삼항연산자**: 아주 간단한 if~ else 문을 한줄로 작성할 수 있는 문법
  ```python
  ans = input('어깨를 돌리셨습니까?') #일반적인 if-else문
    if ans == 'Y':
        print('좋군요')
    else:
        print('그렇군요')
  ```
    
    ```python
    ans = input('어깨를 돌리셨습니까?') #삼항연산자 활용
    print('좋군요' if ans == 'Y' else '그렇군요')
    ```
- 비트 연산은 사용 안 하는 게 좋음: 오류가 안 나더라도 의도대로 동작 안 할 수 있기 때문
  - **논리 연산자**를 사용하자 (ex.| 대신 or 사용해주기)
- **while문**: 횟수가 정해져 있지 않는 경우 사용 
    - 보이지 않아도 돌아가고 있다는 사실 잊지 않기
    - 짧고 덜 반복하는 코드를 만들 수 있도록 늘 신경써야 함
- **이터레이블**: 반복 가능한 모든 종류의 객체
  - 첫 번째 원소~마지막 원소까지 순서대로 접근 가능하면 이터레이블
  - 시퀀스 타입: 리스트, 튜플, 문자열 
- **딕셔너리** 잘 사용할줄 알아야함
  - values(), keys(), items() 사용해서 값 꺼내기
  - dict는 그대로 두고 출력 결과만 바꾸기<br>
    ```python
    for key, value in sale1.items():
    print(key, int(value[0]*0.8), int(value[1]*0.8))
    ```
  
  - dict 안의 value값도 바꿔버리기<br>
  
    ```python
    for key, value in sale1.items():
    for i in range(len(value)):
        value[i] = int(value[i]*0.8)
    ```
- **immutable vs mutable**
  - immutable: 값을 바꿀 수 없는 객체 -> 값이 바뀌면 다른 메모리 공간을 할당해 주소값도 바꿔야 함
    (int, str, float, boolean, tuple..)
  - mutable: 주소값이 동일하더라도 그 안의 값을 바꿀 수 있는 객체
    (list, dict, set...)
- **깊은복사 vs 얕은복사**
  - 얕은 복사: 주소값만 복사 -> 복사 대상 값이 바뀌면 복사한 값도 바뀜 (독립성 x)
  - 깊은 복사: 내부 객체까지 모두 새롭게 copy `copy.deepcopy`
***
<br> 

###  07.11 (4일차)
---
오늘은 내가 좋아하는 참붕어빵이 간식으로 등장했는데 속이 별로 안 좋아서 하나밖에 못 먹은게 슬프다. 그치만 하나 더 챙겨왔음 히히. 근데 중간에 배고파서 예감도 하나 먹었다.. 맨날 생각의 흐름대로 적고 싶은 메모 추가해서 적는건데 나중에 교육내용 어려워지면 학습 정리내용보다 메모가 더 길어질수도. 막 억장 무너지는 글 500줄.. 간식천국에서 공부하는거 너무 행복한데 한 달 지나면 굴러서 출근할 예정. <br><br>

- 어제의 예제 코드 조금 다른 방식으로 짜보기
  - 딕셔너리를 잘 다룰줄 알면 좋음
  ```python
  for k, [v0, v1] in sale1.items():
      if v0>1000:
          print(k,v0)
      if v1>1000:
          print(k,v1)
  ```
- ipynb 파일에서 not defined 오류가 발생한다면 위의 변수정의 셀을 안 돌려본게 아닌지 확인해보기
  - 생각보다 흔한 실수(아니면 자꾸 나만 하는 실수..)
- **함수 사용 방식**
  - 보통 함수 안에 파라미터(아규먼트(인자))가 숨어있음<br>
    `str1.split(sep='/',maxsplit=2)` = `str1.split('/',2)`
  - 정해져 있는 순서대로 넣으면 파라미터 생략 가능<br>
    `str1.split(maxsplit=2, sep='/') #가능`
    `str1.split(2, '/') #불가능`
- **str.replace(old, new[, count])**: 조건에 맞는 문자열 치환
- **str.strip([chars])**: 앞뒤 공백(엔터) 제거
  - rstrip, lsrtp: 오른쪽/왼쪽 공백만 제거 
  - 글자 중간의 공백/char는 제거 불가
    - replace를 이용해서 불필요한 노이즈 제거
- **str.join(iterable)**: split과 반대로 iterable 객체를 string으로 만들어줌<br>
    `' '.join(a) #공백으로 합치기`
    - ex) `dict1 = {'a': 1234, 'b':356}` -> value join 불가
    - `' '.join(dict1.values())`
      - #TypeError: sequence item 0: expected str instance, int found
    - 딕셔너리는 리스트가 아님!
      -`' '.join(str(dict1.values()))`
      - #d i c t _ v a l u e s ( [ ' 1 2 3 4 ' ,   ' 3 5 6 ' ] )
      - 리스트로 바꿔주자 `list(dict1.values())`
- **dictionary 빈도수**
  1. for문 사용 <br>
      ```python
        for word in lyrics:
            if word.casefold() in word_counts:
                word_counts[word.casefold()] += 1
            else:
                word_counts[word.casefold()] = 1
      ```
  2. collections 모듈 사용
     ```python
        import collections
        collections.Counter(lyrics).most_common(10)
     ```
  3. 정규식 사용
     ```python
     p = re.compile('happy', re.IGNORECASE)
     len(p.findall(happy))
     ```
- **dictionary sort by value**
  1. lambda 사용 <br> `sorted(dict.items(), key=lambda x:x[1])`
  2. for문 사용 <br>
      ```python
         count_word_flipped = []
        
         # 반복문으로 (빈도수, 단어) 튜플로 리스트에 적재
         for k, v in word_counts.items():
             count_word_flipped.append((v, k))
         count_word_flipped
        
         sorted(count_word_flipped, reverse=True)[:10]
      ```
- **Chaining 방식**: 함수들이 연결된 형태(왼쪽부터 순서대로 실행)
  `lyrics.replace('(','').replace(')','')`
  - 어떤 함수들은 return이 없어도 달게 되고 어느 순간 데이터가 사라져 원본이 훼손될 수 있음
- 텍스트 전처리 시 고려해야 할 점
  - can't를 can과 not으로 분류할 것인지, cannot으로 분류할 것인지 상황에 맞게 결정해야 함
- **str.find('찾을 문자', [시작인덱스[, 끝인덱스]])**
  - 문자열에 포함된 첫번째 요소의 index값 반환
  - 여러 개 문자가 있을 경우 최초 발견 시작 위치만 알려줌 -> 정규식 사용
- **정규식**: 특정 조건 또는 패턴을 치환하는 과정을 쉽게 처리할 수 있는 방법
  1. 찾을 패턴을 먼저 올려두고 `p = re.compole('a')`
  2. 원하는 과정 처리
     - match() : 문자열의 첫 시작부터 정규식과 매치되는지 조사
     - search() : 문자열 전체를 검색하여 정규식과 매치되는지 조사
     - findall() : 정규식과 매치되는 모든 문자열(substring)을 리스트로 반환
     - finditer() : 정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 반환 <br>
    ex) 알파벳만 찾기<br>
    ```python
    p = re.compile('[a-zA-Z]+')
    p.findall(str1)
    ```
    
     - 정규식 확인 사이트: https://regex101.com/
     - Ctrl+F 를 이용하여 원하는 문자를 한 번에 탐색할 수 있음
       <img src="https://github.com/NopeSieun/WooriFISA_03/assets/83575791/3367a148-cfc5-47d1-805c-8fbf0841fdcd" width="80%" height="80%">
    - ex) 정규식을 활용한 글자 숨기기
      - 세 글자의 가운데 글자를 *처리
          ```python
             name = '안시은'
             re.sub('([가-힣])([가-힣])([가-힣])', r'\1*\3', name) #안*은
          ```
      - 세 글자 이상의 글자에서 양끝 글자만 출력: +를 이용
          ```python
             name = '안시금은'
             re.sub('([가-힣])([가-힣]+)([가-힣])', r'\1*\3', name) #안**은
          ```
- **그루핑 패턴**: 자주 사용하는 패턴은 별명을 지어 부를 수 있음 
    ```python
        p = re.compile(r'(?P<name>\w+)\s+(?P<phone>\d{3}-\d{4}-\d{4})')
        # 별명으로 부른다 \g<그룹명>
        print(p.sub('\g<phone> / \g<name>', string))
    ```
- **출력 문자열 꾸미기**
  - 3d: 정수를 공백 포함 세 자리로 표시
  - 05d: 정수를 다섯 자리로 표시하고 공백은 0 채움
  - .3f: 실수를 소수점 셋째 자리까지 표시
  - ,: 통화 표시(셋째 자리마다 , 표시)
  - .1%: 숫자를 퍼센트로 표시
  - .2e: 숫자를 지수로 표시
  - <: 왼쪽 정렬/>: 오른쪽 정렬/^: 가운데 정렬
- **fstring**: 문자열 앞에 f 붙여줌 -> 직관적인 표현, 실수를 줄여줌 
- **format**: 문자열 추가/형식화
  `'The sum of {} + {} = {}'.format(a, b, a+b)`
- **function**
  - 수학적 의미의 함수: 집합 사이 관계
  - 프로그래밍 언어: 프로그램을 이루는 기본 단위 -> 여러 명령어 집합 (효율적인 프로그래밍 가능)
  - return: 메모리에 가지고 돌아감 (<-> print(): 실행 후 메모리에서 바로 지워짐, 결과 구경만 하는 느낌)
    ```python
    def func(파라미터):
        return f'{파라미터}가 실행됐습니다'
    ```
  - return은 무조건 1개만 가능
    `return (a-b, a*b, a+b, a/b)`
- 가변인자: 입력값 개수가 정해져 있지 않는 경우
  `def 함수명(*arg)`
***
<br> 

###  07.12 (5일차)
---
<br><br>
***
<br> 
